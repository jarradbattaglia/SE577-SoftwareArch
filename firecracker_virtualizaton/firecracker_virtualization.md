# Prompt

Please read this paper:   https://github.com/ArchitectingSoftware/SE577-SoftwareArchitecture/blob/main/reading/firecracker-virtualization.pdf
This paper describes a type of virtual machine that Amazon created for AWS to support the needs of serverless functions.
This paper is not an architecture paper, however, by this point in the course you should be familiar with making architecture decisions based on tradeoffs. 
STEP 1:  When reading the paper, pretend its not a paper describing what AWS built, but instead a proposal to build the firecracker system.  AKA, pretend the paper was written in advance of AWS building firecraker and submitted to AWS CTO - Werner Vogels - as a proposal to fund and support the work to construct it. 
STEP 2:  HIghlight ONE primary architecture decision that you would need to make arguing for the need to create something brand new to support AWS Serverless needs, vs reusing, extending, or enhancing one of the many open source solutions that already existed. 
What to hand in:  A brief writeup on STEP 2 from above.  Motivate why creating a brand new product would be differentiating to AWS, and write it from the perspective that you are trying to convince AWS leadership on undertaking the project. 

# Answer

When deciding to create a new product, we first need to decide how or what we will use as our underlying virtualization layer and what some of our focuses should be.  Many products exist in the market QEMU+KVM, Kata containers, Clear Containers and LightVM for instance virtualization for small scale VMs, and the point that we see from these products, especially QEMU is more of flexibility and feature completeness of linux functions, when our primary concerns are around resource overhead, security and startup times and decreasing complexity.  

So the first archiecture desiciion we might make is the need to write our own VMM in a way that decreases complexity and with that we need to choose a programming language.  When looking at the public options available such as QEMU, the first thing that we see is high code complexity, for instance QEMU has 1.5 million lines of code and requires a high amount of syscalls increasing its security and performance reach, and other projects aimed at decreasing this complexity, such as NEMU are no longer supported.  So for us to achieve our goals, we can not leverage anything out in the open and using a modern language we will be able to decrease our code size substantially and include only features that we require.  For instance, using something like the Rust programming language allows us to decrease lines of code substantially, have multiple levels of automated tests and auto generate bindings.  This decrease in code and minimizing our feature set should allow us to have better performance, maintainability, and most importantly decrease the security that we are subject to as we limit the number of syscalls and can support syscalls that have a low amount of bugs, while also having support for a wide range of linux kernels.
