# Prompt

Please read this paper:   https://github.com/ArchitectingSoftware/SE577-SoftwareArchitecture/blob/main/reading/firecracker-virtualization.pdf
This paper describes a type of virtual machine that Amazon created for AWS to support the needs of serverless functions.
This paper is not an architecture paper, however, by this point in the course you should be familiar with making architecture decisions based on tradeoffs. 
STEP 1:  When reading the paper, pretend its not a paper describing what AWS built, but instead a proposal to build the firecracker system.  AKA, pretend the paper was written in advance of AWS building firecraker and submitted to AWS CTO - Werner Vogels - as a proposal to fund and support the work to construct it. 
STEP 2:  HIghlight ONE primary architecture decision that you would need to make arguing for the need to create something brand new to support AWS Serverless needs, vs reusing, extending, or enhancing one of the many open source solutions that already existed. 
What to hand in:  A brief writeup on STEP 2 from above.  Motivate why creating a brand new product would be differentiating to AWS, and write it from the perspective that you are trying to convince AWS leadership on undertaking the project. 

# Answer

When deciding to create a new product for AWS Serverless needs, we first need to decide how or what we will use as our underlying virtualization layer and what some of our focuses should be.  Many products exist in the market today QEMU+KVM, Kata containers, Clear Containers and LightVM for instance virtualization for small scale VMs, and the point that we see from these products, especially QEMU+KVM (which is the most used in this space) is more built for linux flexibility and feature completeness of linux functions, where as our primary concerns are around resource overhead, security, startup times and decreasing code complexity, which in my opinion makes the open source options unavailable for our use cases.   

So the first archiecture desicion we might make is the need to write our own VMM in a way that decreases code complexity and enhances maintainability and with that we need to choose a programming language.  When looking at the public options available such as QEMU, the first thing that we see is high code complexity, for instance QEMU has 1.5 million lines of code and requires a high amount of syscalls increasing its security concerns and performance issues.  Other projects aimed at decreasing this complexity, such as NEMU are no longer supported.  So for us to achieve our goals, we can not leverage anything out in the open source community and using a modern programming language, we will be able to decrease our code size substantially and include only features that we require.  

For instance, using something like the Rust programming language allows us to decrease lines of code substantially (a fraction of the code QEMU supports), have multiple levels of automated tests and auto generated bindings.  This decrease in code complexity and minimizing our feature set should allow us to have dramatically better performance, easier maintainability, and maybe most importantly decrease the security issues that we are subject to as we limit the number of syscalls and can support syscalls that have a low amount of bugs, while also having support for a wide range of linux kernels.  If we used open source projects, many of our requirements would be impossible or require a large amount time to reverse engineer existing solutions to get what we need and writing something in addition to supporting that product.
